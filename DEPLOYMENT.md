# Friendo - Deployment Guide

This guide covers deploying the Friendo application in various environments.

## Table of Contents

- [Prerequisites](#prerequisites)
- [Environment Configuration](#environment-configuration)
- [Docker Deployment (Recommended)](#docker-deployment-recommended)
- [Manual Deployment](#manual-deployment)
- [Cloud Deployment](#cloud-deployment)
- [Monitoring & Logging](#monitoring--logging)
- [Troubleshooting](#troubleshooting)

---

## Prerequisites

### For Docker Deployment (Recommended)
- **Docker** 20.10+ and **Docker Compose** 2.0+
- **Google Gemini API Key** - Get from [Google AI Studio](https://aistudio.google.com/)

### For Manual Deployment
- **Python** 3.11+
- **Node.js** 20+ and **npm** 10+

### Optional
- **PostgreSQL** 14+ (for production database, SQLite used by default)

---

## Environment Configuration

### Automatic Setup (Recommended)

```bash
# Windows
.\setup.ps1

# Linux/Mac  
./setup.sh
```

This automatically creates `.env` and generates the encryption key.

### Manual Setup

```bash
cp .env.example .env
```

Then generate an encryption key:

```bash
python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
```

### Required Variables

```env
# Auto-generated by setup script
ENCRYPTION_KEY=your-generated-fernet-key

# Get from https://aistudio.google.com/
GEMINI_API_KEY=your_gemini_api_key
```

### Optional Variables

```env
PORT=8000
WORKERS=2
GEMINI_MODEL=gemini-2.0-flash
DATABASE_URL=sqlite:///./friendo.db
CORS_ORIGINS=*
```

---

## Docker Deployment (Recommended)

### Quick Start

**Step 1: Run the setup script**

```bash
# Windows PowerShell
.\setup.ps1

# Linux/Mac
chmod +x setup.sh && ./setup.sh
```

This will:
- Create `.env` from the template
- Auto-generate the `ENCRYPTION_KEY`

**Step 2: Add your Gemini API Key**

Open the `.env` file and add your API key:

```env
GEMINI_API_KEY=your_gemini_api_key_here
```

> ðŸ’¡ Get your free API key from [Google AI Studio](https://aistudio.google.com/)

**Step 3: Build and run**

```bash
docker compose up --build
```

The app will be available at **http://localhost:8000**

---

### Passing API Keys to Docker

There are multiple ways to provide API keys to the Docker container:

#### Option 1: Using .env file (Recommended for local dev)

Create a `.env` file with your keys:

```env
ENCRYPTION_KEY=your-fernet-key
GEMINI_API_KEY=your-gemini-api-key
```

Then run:

```bash
docker compose up --build
```

The `docker-compose.yml` automatically loads from `.env`.

#### Option 2: Environment variables on command line

```bash
# Single command with inline env vars
docker run -d \
  --name friendo \
  -p 8000:8000 \
  -e GEMINI_API_KEY="your-api-key-here" \
  -e ENCRYPTION_KEY="your-fernet-key" \
  -v friendo_data:/app/data \
  friendo:latest
```

#### Option 3: Using --env-file flag

```bash
# Build the image first
docker build -t friendo .

# Run with env file
docker run -d \
  --name friendo \
  -p 8000:8000 \
  --env-file .env \
  -v friendo_data:/app/data \
  friendo:latest
```

#### Option 4: Docker Compose with explicit environment

You can also override values in `docker-compose.yml`:

```yaml
services:
  friendo:
    environment:
      - GEMINI_API_KEY=${GEMINI_API_KEY}  # From shell env
      - ENCRYPTION_KEY=hardcoded-key-here  # Or hardcode
```

Then export and run:

```bash
export GEMINI_API_KEY="your-key"
docker compose up --build
```

---

### Docker Commands Reference

```bash
# Build and start (foreground)
docker compose up --build

# Build and start (background/detached)
docker compose up -d --build

# View live logs
docker compose logs -f

# View logs for specific service
docker compose logs -f friendo

# Stop containers
docker compose down

# Stop and remove volumes (resets database)
docker compose down -v

# Rebuild after code changes
docker compose up --build --force-recreate

# Check container status
docker compose ps
```

---

### Building the Image Separately

```bash
# Build the optimized production image (~180MB, Alpine-based)
docker build -t friendo:latest .

# Tag for a registry
docker tag friendo:latest your-registry.com/friendo:latest

# Push to registry
docker push your-registry.com/friendo:latest
```

---

### Production Docker Compose

For production, create a `docker-compose.prod.yml`:

```yaml
services:
  friendo:
    image: friendo:latest
    container_name: friendo
    ports:
      - "8000:8000"
    environment:
      - ENVIRONMENT=production
      - DEBUG=false
      - GEMINI_API_KEY=${GEMINI_API_KEY}
      - ENCRYPTION_KEY=${ENCRYPTION_KEY}
      - DATABASE_URL=sqlite:///./data/friendo.db
    volumes:
      - friendo-data:/app/data
    restart: always
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/api/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  friendo-data:
```

Run with:

```bash
docker compose -f docker-compose.prod.yml up -d
```

---

## Manual Deployment

### Backend Setup

```bash
cd backend

# Create virtual environment
python -m venv venv

# Activate (Windows)
.\venv\Scripts\Activate

# Activate (Linux/macOS)
source venv/bin/activate

# Install dependencies
pip install -r requirements.txt

# Set environment variables
export GEMINI_API_KEY=your_key
export ENCRYPTION_KEY=your_encryption_key
export ENVIRONMENT=production

# Run with Gunicorn (production)
gunicorn main:app -w 4 -k uvicorn.workers.UvicornWorker -b 0.0.0.0:8000

# Or run with Uvicorn (development)
uvicorn main:app --host 0.0.0.0 --port 8000 --reload
```

### Frontend Setup

```bash
cd frontend

# Install dependencies
npm install

# Build for production
npm run build

# The built files are in dist/ - serve with any static file server
```

### Serving Frontend with Nginx

Example Nginx configuration:

```nginx
server {
    listen 80;
    server_name yourdomain.com;

    # Frontend static files
    location / {
        root /var/www/friendo/frontend/dist;
        try_files $uri $uri/ /index.html;
    }

    # Backend API proxy
    location /api/ {
        proxy_pass http://localhost:8000/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }
}
```

---

## Cloud Deployment

### Azure Container Apps

```bash
# Login to Azure
az login

# Create resource group
az group create --name friendo-rg --location eastus

# Create Container Apps environment
az containerapp env create \
  --name friendo-env \
  --resource-group friendo-rg \
  --location eastus

# Deploy container
az containerapp create \
  --name friendo \
  --resource-group friendo-rg \
  --environment friendo-env \
  --image your-registry/friendo:latest \
  --target-port 8000 \
  --ingress external \
  --env-vars \
    GEMINI_API_KEY=secretref:gemini-key \
    ENCRYPTION_KEY=secretref:encryption-key \
    ENVIRONMENT=production
```

### AWS ECS / Fargate

1. Push image to ECR:
```bash
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin YOUR_ACCOUNT.dkr.ecr.us-east-1.amazonaws.com

docker tag friendo:latest YOUR_ACCOUNT.dkr.ecr.us-east-1.amazonaws.com/friendo:latest
docker push YOUR_ACCOUNT.dkr.ecr.us-east-1.amazonaws.com/friendo:latest
```

2. Create ECS task definition and service using AWS Console or CLI.

### Google Cloud Run

```bash
# Build and push to GCR
gcloud builds submit --tag gcr.io/YOUR_PROJECT/friendo

# Deploy
gcloud run deploy friendo \
  --image gcr.io/YOUR_PROJECT/friendo \
  --platform managed \
  --region us-central1 \
  --allow-unauthenticated \
  --set-env-vars "GEMINI_API_KEY=your_key,ENVIRONMENT=production" \
  --set-secrets "ENCRYPTION_KEY=encryption-key:latest"
```

### Railway / Render / Fly.io

These platforms support Docker deployments. Simply connect your GitHub repository and configure environment variables in their dashboard.

---

## Monitoring & Logging

### Application Logs

Logs are output to stdout/stderr and can be captured by Docker or your orchestration platform.

**Log Levels:**
- `DEBUG`: Detailed debugging information (development only)
- `INFO`: General operational messages
- `WARNING`: Warning messages
- `ERROR`: Error messages

Set log level via environment:
```env
LOG_LEVEL=INFO
```

### Health Check Endpoint

```bash
curl http://localhost:8000/health
```

Response:
```json
{
  "status": "healthy",
  "version": "1.0.0",
  "environment": "production"
}
```

### Metrics (Optional)

For production monitoring, consider adding:
- **Prometheus** metrics endpoint
- **Application Insights** (Azure)
- **CloudWatch** (AWS)
- **Cloud Monitoring** (GCP)

---

## Troubleshooting

### Common Issues

#### 1. Container fails to start

```bash
# Check logs
docker-compose logs app

# Common causes:
# - Missing GEMINI_API_KEY
# - Invalid ENCRYPTION_KEY (must be 32 characters)
# - Port 8000 already in use
```

#### 2. API returns 500 errors

```bash
# Check if LLM API keys are valid
curl -X POST http://localhost:8000/tasks/decompose \
  -H "Content-Type: application/json" \
  -d '{"goal": "test task"}'

# Check application logs for detailed errors
```

#### 3. Frontend can't connect to backend

- Verify CORS_ORIGINS includes your frontend domain
- Check if backend is running: `curl http://localhost:8000/health`
- Verify network/firewall rules allow traffic

#### 4. Database errors

```bash
# For SQLite - check file permissions
ls -la *.db

# For PostgreSQL - verify connection string
# DATABASE_URL=postgresql://user:pass@host:5432/dbname
```

### Performance Tuning

```env
# Increase workers for higher traffic
WORKERS=8

# Adjust based on CPU cores (recommended: 2-4 Ã— CPU cores)
```

### Security Checklist

- [ ] Change default ENCRYPTION_KEY
- [ ] Use HTTPS in production (use reverse proxy like Nginx)
- [ ] Set restrictive CORS_ORIGINS
- [ ] Keep API keys in secure secrets manager
- [ ] Enable rate limiting
- [ ] Regular security updates for dependencies

---

## Support

For issues and feature requests, please open an issue on the GitHub repository.
